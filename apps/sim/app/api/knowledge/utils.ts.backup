import { db } from "@/db";
import { document, embedding, knowledgeBase } from "@/db/schema";
import { processDocument } from "@/lib/documents/document-processor";
import { retryWithExponentialBackoff } from "@/lib/documents/utils";
import { env } from "@/lib/env";
import { createLogger } from "@/lib/logs/console/logger";
import { getUserEntityPermissions } from "@/lib/permissions/utils";
import crypto from "crypto";
import { and, eq, isNull } from "drizzle-orm";

const logger = createLogger("KnowledgeUtils");

// Timeout constants (in milliseconds)
const TIMEOUTS = {
  OVERALL_PROCESSING: 150000, // 150 seconds (2.5 minutes)
  EMBEDDINGS_API: 60000, // 60 seconds per batch
} as const;

class APIError extends Error {
  public status: number;

  constructor(message: string, status: number) {
    super(message);
    this.name = "APIError";
    this.status = status;
  }
}

/**
 * Create a timeout wrapper for async operations
 */
function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  operation = "Operation"
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) =>
      setTimeout(
        () => reject(new Error(`${operation} timed out after ${timeoutMs}ms`)),
        timeoutMs
      )
    ),
  ]);
}

export interface KnowledgeBaseData {
  id: string;
  userId: string;
  workspaceId?: string | null;
  name: string;
  description?: string | null;
  tokenCount: number;
  embeddingModel: string;
  embeddingDimension: number;
  chunkingConfig: unknown;
  deletedAt?: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface DocumentData {
  id: string;
  knowledgeBaseId: string;
  filename: string;
  fileUrl: string;
  fileSize: number;
  mimeType: string;
  chunkCount: number;
  tokenCount: number;
  characterCount: number;
  processingStatus: string;
  processingStartedAt?: Date | null;
  processingCompletedAt?: Date | null;
  processingError?: string | null;
  enabled: boolean;
  deletedAt?: Date | null;
  uploadedAt: Date;
  // Document tags
  tag1?: string | null;
  tag2?: string | null;
  tag3?: string | null;
  tag4?: string | null;
  tag5?: string | null;
  tag6?: string | null;
  tag7?: string | null;
}

export interface EmbeddingData {
  id: string;
  knowledgeBaseId: string;
  documentId: string;
  chunkIndex: number;
  chunkHash: string;
  content: string;
  contentLength: number;
  tokenCount: number;
  embedding?: number[] | null;
  embeddingModel: string;
  startOffset: number;
  endOffset: number;
  // Tag fields for filtering
  tag1?: string | null;
  tag2?: string | null;
  tag3?: string | null;
  tag4?: string | null;
  tag5?: string | null;
  tag6?: string | null;
  tag7?: string | null;
  enabled: boolean;
  createdAt: Date;
  updatedAt: Date;
}

interface OpenAIEmbeddingResponse {
  data: Array<{
    embedding: number[];
    index: number;
  }>;
  model: string;
  usage: {
    prompt_tokens: number;
    total_tokens: number;
  };
}

interface QwenEmbeddingResponse {
  output: {
    embeddings: Array<{
      embedding: number[];
      text_index: number;
    }>;
  };
  usage: {
    total_tokens: number;
  };
}

export interface KnowledgeBaseAccessResult {
  hasAccess: true;
  knowledgeBase: Pick<KnowledgeBaseData, "id" | "userId">;
}

export interface KnowledgeBaseAccessDenied {
  hasAccess: false;
  notFound?: boolean;
  reason?: string;
}

export type KnowledgeBaseAccessCheck =
  | KnowledgeBaseAccessResult
  | KnowledgeBaseAccessDenied;

export interface DocumentAccessResult {
  hasAccess: true;
  document: DocumentData;
  knowledgeBase: Pick<KnowledgeBaseData, "id" | "userId">;
}

export interface DocumentAccessDenied {
  hasAccess: false;
  notFound?: boolean;
  reason: string;
}

export type DocumentAccessCheck = DocumentAccessResult | DocumentAccessDenied;

export interface ChunkAccessResult {
  hasAccess: true;
  chunk: EmbeddingData;
  document: DocumentData;
  knowledgeBase: Pick<KnowledgeBaseData, "id" | "userId">;
}

export interface ChunkAccessDenied {
  hasAccess: false;
  notFound?: boolean;
  reason: string;
}

export type ChunkAccessCheck = ChunkAccessResult | ChunkAccessDenied;

/**
 * Check if a user has access to a knowledge base
 */
export async function checkKnowledgeBaseAccess(
  knowledgeBaseId: string,
  userId: string
): Promise<KnowledgeBaseAccessCheck> {
  const kb = await db
    .select({
      id: knowledgeBase.id,
      userId: knowledgeBase.userId,
      workspaceId: knowledgeBase.workspaceId,
    })
    .from(knowledgeBase)
    .where(
      and(
        eq(knowledgeBase.id, knowledgeBaseId),
        isNull(knowledgeBase.deletedAt)
      )
    )
    .limit(1);

  if (kb.length === 0) {
    return { hasAccess: false, notFound: true };
  }

  const kbData = kb[0];

  // Case 1: User owns the knowledge base directly
  if (kbData.userId === userId) {
    return { hasAccess: true, knowledgeBase: kbData };
  }

  // Case 2: Knowledge base belongs to a workspace the user has permissions for
  if (kbData.workspaceId) {
    const userPermission = await getUserEntityPermissions(
      userId,
      "workspace",
      kbData.workspaceId
    );
    if (userPermission !== null) {
      return { hasAccess: true, knowledgeBase: kbData };
    }
  }

  return { hasAccess: false };
}

/**
 * Check if a user has write access to a knowledge base
 * Write access is granted if:
 * 1. User owns the knowledge base directly, OR
 * 2. User has write or admin permissions on the knowledge base's workspace
 */
export async function checkKnowledgeBaseWriteAccess(
  knowledgeBaseId: string,
  userId: string
): Promise<KnowledgeBaseAccessCheck> {
  const kb = await db
    .select({
      id: knowledgeBase.id,
      userId: knowledgeBase.userId,
      workspaceId: knowledgeBase.workspaceId,
    })
    .from(knowledgeBase)
    .where(
      and(
        eq(knowledgeBase.id, knowledgeBaseId),
        isNull(knowledgeBase.deletedAt)
      )
    )
    .limit(1);

  if (kb.length === 0) {
    return { hasAccess: false, notFound: true };
  }

  const kbData = kb[0];

  // Case 1: User owns the knowledge base directly
  if (kbData.userId === userId) {
    return { hasAccess: true, knowledgeBase: kbData };
  }

  // Case 2: Knowledge base belongs to a workspace and user has write/admin permissions
  if (kbData.workspaceId) {
    const userPermission = await getUserEntityPermissions(
      userId,
      "workspace",
      kbData.workspaceId
    );
    if (userPermission === "write" || userPermission === "admin") {
      return { hasAccess: true, knowledgeBase: kbData };
    }
  }

  return { hasAccess: false };
}

/**
 * Check if a user has write access to a specific document
 * Write access is granted if user has write access to the knowledge base
 */
export async function checkDocumentWriteAccess(
  knowledgeBaseId: string,
  documentId: string,
  userId: string
): Promise<DocumentAccessCheck> {
  // First check if user has write access to the knowledge base
  const kbAccess = await checkKnowledgeBaseWriteAccess(knowledgeBaseId, userId);

  if (!kbAccess.hasAccess) {
    return {
      hasAccess: false,
      notFound: kbAccess.notFound,
      reason: kbAccess.notFound
        ? "Knowledge base not found"
        : "Unauthorized knowledge base access",
    };
  }

  // Check if document exists
  const doc = await db
    .select({
      id: document.id,
      filename: document.filename,
      fileUrl: document.fileUrl,
      fileSize: document.fileSize,
      mimeType: document.mimeType,
      chunkCount: document.chunkCount,
      tokenCount: document.tokenCount,
      characterCount: document.characterCount,
      enabled: document.enabled,
      processingStatus: document.processingStatus,
      processingError: document.processingError,
      uploadedAt: document.uploadedAt,
      processingStartedAt: document.processingStartedAt,
      processingCompletedAt: document.processingCompletedAt,
      knowledgeBaseId: document.knowledgeBaseId,
    })
    .from(document)
    .where(and(eq(document.id, documentId), isNull(document.deletedAt)))
    .limit(1);

  if (doc.length === 0) {
    return { hasAccess: false, notFound: true, reason: "Document not found" };
  }

  return {
    hasAccess: true,
    document: doc[0] as DocumentData,
    knowledgeBase: kbAccess.knowledgeBase!,
  };
}

/**
 * Check if a user has access to a document within a knowledge base
 */
export async function checkDocumentAccess(
  knowledgeBaseId: string,
  documentId: string,
  userId: string
): Promise<DocumentAccessCheck> {
  // First check if user has access to the knowledge base
  const kbAccess = await checkKnowledgeBaseAccess(knowledgeBaseId, userId);

  if (!kbAccess.hasAccess) {
    return {
      hasAccess: false,
      notFound: kbAccess.notFound,
      reason: kbAccess.notFound
        ? "Knowledge base not found"
        : "Unauthorized knowledge base access",
    };
  }

  const doc = await db
    .select()
    .from(document)
    .where(
      and(
        eq(document.id, documentId),
        eq(document.knowledgeBaseId, knowledgeBaseId),
        isNull(document.deletedAt)
      )
    )
    .limit(1);

  if (doc.length === 0) {
    return { hasAccess: false, notFound: true, reason: "Document not found" };
  }

  return {
    hasAccess: true,
    document: doc[0] as DocumentData,
    knowledgeBase: kbAccess.knowledgeBase!,
  };
}

/**
 * Check if a user has access to a chunk within a document and knowledge base
 */
export async function checkChunkAccess(
  knowledgeBaseId: string,
  documentId: string,
  chunkId: string,
  userId: string
): Promise<ChunkAccessCheck> {
  // First check if user has access to the knowledge base
  const kbAccess = await checkKnowledgeBaseAccess(knowledgeBaseId, userId);

  if (!kbAccess.hasAccess) {
    return {
      hasAccess: false,
      notFound: kbAccess.notFound,
      reason: kbAccess.notFound
        ? "Knowledge base not found"
        : "Unauthorized knowledge base access",
    };
  }

  const doc = await db
    .select()
    .from(document)
    .where(
      and(
        eq(document.id, documentId),
        eq(document.knowledgeBaseId, knowledgeBaseId),
        isNull(document.deletedAt)
      )
    )
    .limit(1);

  if (doc.length === 0) {
    return { hasAccess: false, notFound: true, reason: "Document not found" };
  }

  const docData = doc[0] as DocumentData;

  // Check if document processing is completed
  if (docData.processingStatus !== "completed") {
    return {
      hasAccess: false,
      reason: `Document is not ready for access (status: ${docData.processingStatus})`,
    };
  }

  const chunk = await db
    .select()
    .from(embedding)
    .where(and(eq(embedding.id, chunkId), eq(embedding.documentId, documentId)))
    .limit(1);

  if (chunk.length === 0) {
    return { hasAccess: false, notFound: true, reason: "Chunk not found" };
  }

  return {
    hasAccess: true,
    chunk: chunk[0] as EmbeddingData,
    document: docData,
    knowledgeBase: kbAccess.knowledgeBase!,
  };
}

/**
 * Generate embeddings using OpenAI API with retry logic for rate limiting
 */
export async function generateEmbeddings(
  texts: string[],
  embeddingModel = "text-embedding-v4"
): Promise<number[][]> {
  const dashscopeApiKey = env.DASHSCOPE_API_KEY;
  if (!dashscopeApiKey) {
    throw new Error("DASHSCOPE_API_KEY not configured");
  }

  try {
    const batchSize = 100;
    const allEmbeddings: number[][] = [];

    for (let i = 0; i < texts.length; i += batchSize) {
      const batch = texts.slice(i, i + batchSize);

      logger.info(
        `Generating embeddings for batch ${Math.floor(i / batchSize) + 1} (${batch.length} texts) using Qwen3-Embedding`
      );

      const batchEmbeddings = await retryWithExponentialBackoff(
        async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(
            () => controller.abort(),
            TIMEOUTS.EMBEDDINGS_API
          );

          try {
            // Ensure all texts are valid strings and clean them
            const cleanedBatch = batch
              .map((text) => {
                if (typeof text !== "string") {
                  return String(text);
                }

                // Clean the text: remove null bytes, normalize whitespace, limit length
                let cleaned = text
                  .replace(/\0/g, "") // Remove null bytes
                  .replace(/\r\n/g, "\n") // Normalize line endings
                  .replace(/\r/g, "\n") // Normalize line endings
                  .replace(/[\u0000-\u001F\u007F-\u009F]/g, "") // Remove control characters
                  .replace(/[^\x00-\x7F\u4E00-\u9FFF]/g, (char) => {
                    // Keep Chinese characters and basic ASCII, but log suspicious ones
                    if (char.charCodeAt(0) > 0xffff) {
                      logger.warn(
                        `Found high surrogate character: ${char.charCodeAt(0).toString(16)}`
                      );
                    }
                    return char;
                  })
                  .trim();

                // Limit text length to 8000 characters (Qwen API limit)
                if (cleaned.length > 8000) {
                  logger.warn(
                    `Text too long (${cleaned.length} chars), truncating to 8000 chars`
                  );
                  cleaned = cleaned.substring(0, 8000) + "...";
                }

                return cleaned;
              })
              .filter((text) => text.length > 0);

            if (cleanedBatch.length === 0) {
              logger.warn("Batch contains no valid texts, skipping");
              return [];
            }

            logger.info(
              `Sending ${cleanedBatch.length} texts to Qwen3-Embedding API (total chars: ${cleanedBatch.reduce((sum, t) => sum + t.length, 0)})`
            );

            // Prepare request body and validate it
            const requestBody = {
              model: embeddingModel,
              input: cleanedBatch,
            };

            // Validate that the request body can be properly serialized
            let requestBodyJson;
            try {
              requestBodyJson = JSON.stringify(requestBody);
              logger.debug(
                `Request body JSON length: ${requestBodyJson.length} chars`
              );
            } catch (jsonError) {
              const errorMessage =
                jsonError instanceof Error
                  ? jsonError.message
                  : String(jsonError);
              logger.error(
                "Failed to serialize request body to JSON:",
                jsonError
              );
              throw new Error(
                `Failed to serialize request body: ${errorMessage}`
              );
            }

            // Try with shorter text first
            let requestBodyToUse = requestBody;

            // If any text is too long, try with truncated version
            if (cleanedBatch.some((text) => text.length > 1000)) {
              logger.info(
                "Some texts are long, trying with truncated versions..."
              );
              requestBodyToUse = {
                model: embeddingModel,
                input: cleanedBatch.map((text) => text.substring(0, 1000)),
              };
            }

            const finalRequestBodyJson = JSON.stringify(requestBodyToUse);
            logger.debug(
              `Final request body JSON length: ${finalRequestBodyJson.length} chars`
            );

            // Use the successful compatible mode endpoint directly
            logger.info("Calling Qwen3-Embedding API via compatible mode...");

            let response;

            // First try: Standard Qwen API format
            try {
              logger.info("Trying standard Qwen API format...");
              response = await fetch(
                "https://dashscope.aliyuncs.com/api/v1/services/embeddings/text-embedding-v4/text-embedding",
                {
                  method: "POST",
                  headers: {
                    Authorization: `Bearer ${dashscopeApiKey}`,
                    "Content-Type": "application/json",
                    "X-DashScope-SSE": "disable",
                  },
                  body: finalRequestBodyJson,
                  signal: controller.signal,
                }
              );

              if (response.ok) {
                logger.info("Standard Qwen API format successful");
              } else {
                lastError = await response.text();
                logger.warn(
                  `Standard Qwen format failed: ${response.status} - ${lastError}`
                );
              }
            } catch (error) {
              const errorMessage =
                error instanceof Error ? error.message : String(error);
              logger.warn(`Standard Qwen format error: ${errorMessage}`);
            }

            // Second try: Alternative format with different model name
            if (!response || !response.ok) {
              try {
                logger.info("Trying alternative API format...");
                const alternativeBody = {
                  model: "text-embedding-v4",
                  input: cleanedBatch.map((text) => text.substring(0, 500)), // Limit to 500 chars
                };

                const alternativeJson = JSON.stringify(alternativeBody);
                logger.debug(`Alternative request body: ${alternativeJson}`);

                response = await fetch(
                  "https://dashscope.aliyuncs.com/api/v1/services/embeddings/text-embedding/text-embedding",
                  {
                    method: "POST",
                    headers: {
                      Authorization: `Bearer ${dashscopeApiKey}`,
                      "Content-Type": "application/json",
                      "X-DashScope-SSE": "disable",
                    },
                    body: alternativeJson,
                    signal: controller.signal,
                  }
                );

                if (response.ok) {
                  logger.info("Alternative API format successful");
                } else {
                  lastError = await response.text();
                  logger.warn(
                    `Alternative format failed: ${response.status} - ${lastError}`
                  );
                }
              } catch (error) {
                const errorMessage =
                  error instanceof Error ? error.message : String(error);
                logger.warn(`Alternative format error: ${errorMessage}`);
              }
            }

            // Third try: Use the compatible mode endpoint
            if (!response || !response.ok) {
              try {
                logger.info("Trying compatible mode endpoint...");
                const compatibleBody = {
                  model: "text-embedding-v4",
                  input: cleanedBatch.map((text) => text.substring(0, 300)), // Limit to 300 chars
                };

                const compatibleJson = JSON.stringify(compatibleBody);
                logger.debug(`Compatible request body: ${compatibleJson}`);

                response = await fetch(
                  "https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings",
                  {
                    method: "POST",
                    headers: {
                      Authorization: `Bearer ${dashscopeApiKey}`,
                      "Content-Type": "application/json",
                    },
                    body: compatibleJson,
                    signal: controller.signal,
                  }
                );

                if (response.ok) {
                  logger.info("Compatible mode endpoint successful");
                } else {
                  lastError = await response.text();
                  logger.warn(
                    `Compatible mode failed: ${response.status} - ${lastError}`
                  );
                }
              } catch (error) {
                const errorMessage =
                  error instanceof Error ? error.message : String(error);
                logger.warn(`Compatible mode error: ${errorMessage}`);
              }
            }

            // If all attempts failed, throw error
            if (!response || !response.ok) {
              throw new Error(
                `All API attempts failed. Last error: ${lastError || "Unknown error"}`
              );
            }

            clearTimeout(timeoutId);

            if (!response.ok) {
              const errorText = await response.text();
              logger.error("Qwen3-Embedding API error response:", {
                status: response.status,
                statusText: response.statusText,
                errorText,
                requestBody: {
                  model: embeddingModel,
                  input: cleanedBatch,
                },
                // Add more debugging info
                inputLengths: cleanedBatch.map((text, i) => ({
                  index: i,
                  length: text.length,
                })),
                totalChars: cleanedBatch.reduce((sum, t) => sum + t.length, 0),
                sampleText: cleanedBatch[0]?.substring(0, 200) + "...",
              });
              const error = new APIError(
                `Qwen3-Embedding API error: ${response.status} ${response.statusText} - ${errorText}`,
                response.status
              );
              throw error;
            }

            const data = await response.json();

            // Parse response based on which endpoint succeeded
            if (data.output && data.output.embeddings) {
              // Qwen API format
              logger.info("Using Qwen API response format");
              return data.output.embeddings.map((item: any) => item.embedding);
            }

            if (data.data && Array.isArray(data.data)) {
              // OpenAI compatible format (Compatible Mode)
              logger.info("Using OpenAI compatible response format");
              return data.data.map((item: any) => item.embedding);
            }

            logger.error("Unknown response format:", data);
            throw new Error("Unknown API response format");
          } catch (error) {
            clearTimeout(timeoutId);
            if (error instanceof Error && error.name === "AbortError") {
              throw new Error("Qwen3-Embedding API request timed out");
            }
            throw error;
          }
        },
        {
          maxRetries: 5,
          initialDelayMs: 1000,
          maxDelayMs: 60000, // Max 1 minute delay for embeddings
          backoffMultiplier: 2,
        }
      );

      allEmbeddings.push(...batchEmbeddings);
    }

    return allEmbeddings;
  } catch (error) {
    logger.error("Failed to generate embeddings:", error);
    throw error;
  }
}

/**
 * Process a document asynchronously with full error handling
 */
export async function processDocumentAsync(
  knowledgeBaseId: string,
  documentId: string,
  docData: {
    filename: string;
    fileUrl: string;
    fileSize: number;
    mimeType: string;
  },
  processingOptions: {
    chunkSize?: number;
    minCharactersPerChunk?: number;
    recipe?: string;
    lang?: string;
    chunkOverlap?: number;
  }
): Promise<void> {
  const startTime = Date.now();
  try {
    logger.info(
      `[${documentId}] Starting document processing: ${docData.filename}`
    );

    // Set status to processing
    await db
      .update(document)
      .set({
        processingStatus: "processing",
        processingStartedAt: new Date(),
        processingError: null, // Clear any previous error
      })
      .where(eq(document.id, documentId));

    logger.info(
      `[${documentId}] Status updated to 'processing', starting document processor`
    );

    // Wrap the entire processing operation with a 5-minute timeout
    await withTimeout(
      (async () => {
        const processed = await processDocument(
          docData.fileUrl,
          docData.filename,
          docData.mimeType,
          processingOptions.chunkSize || 1000,
          processingOptions.chunkOverlap || 200,
          processingOptions.minCharactersPerChunk || 1
        );

        const now = new Date();

        logger.info(
          `[${documentId}] Document parsed successfully, generating embeddings for ${processed.chunks.length} chunks`
        );

        const chunkTexts = processed.chunks.map((chunk) => chunk.text);
        const embeddings =
          chunkTexts.length > 0 ? await generateEmbeddings(chunkTexts) : [];

        logger.info(
          `[${documentId}] Embeddings generated, fetching document tags`
        );

        // Fetch document to get tags
        const documentRecord = await db
          .select({
            tag1: document.tag1,
            tag2: document.tag2,
            tag3: document.tag3,
            tag4: document.tag4,
            tag5: document.tag5,
            tag6: document.tag6,
            tag7: document.tag7,
          })
          .from(document)
          .where(eq(document.id, documentId))
          .limit(1);

        const documentTags = documentRecord[0] || {};

        logger.info(`[${documentId}] Creating embedding records with tags`);

        const embeddingRecords = processed.chunks.map((chunk, chunkIndex) => ({
          id: crypto.randomUUID(),
          knowledgeBaseId,
          documentId,
          chunkIndex,
          chunkHash: crypto
            .createHash("sha256")
            .update(chunk.text)
            .digest("hex"),
          content: chunk.text,
          contentLength: chunk.text.length,
          tokenCount: Math.ceil(chunk.text.length / 4),
          embedding: embeddings[chunkIndex] || null,
          embeddingModel: "text-embedding-3-small",
          startOffset: chunk.metadata.startIndex,
          endOffset: chunk.metadata.endIndex,
          // Copy tags from document
          tag1: documentTags.tag1,
          tag2: documentTags.tag2,
          tag3: documentTags.tag3,
          tag4: documentTags.tag4,
          tag5: documentTags.tag5,
          tag6: documentTags.tag6,
          tag7: documentTags.tag7,
          createdAt: now,
          updatedAt: now,
        }));

        await db.transaction(async (tx) => {
          if (embeddingRecords.length > 0) {
            await tx.insert(embedding).values(embeddingRecords);
          }

          await tx
            .update(document)
            .set({
              chunkCount: processed.metadata.chunkCount,
              tokenCount: processed.metadata.tokenCount,
              characterCount: processed.metadata.characterCount,
              processingStatus: "completed",
              processingCompletedAt: now,
              processingError: null,
            })
            .where(eq(document.id, documentId));
        });
      })(),
      TIMEOUTS.OVERALL_PROCESSING,
      "Document processing"
    );

    const processingTime = Date.now() - startTime;
    logger.info(
      `[${documentId}] Successfully processed document in ${processingTime}ms`
    );
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error(
      `[${documentId}] Failed to process document after ${processingTime}ms:`,
      {
        error: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
        filename: docData.filename,
        fileUrl: docData.fileUrl,
        mimeType: docData.mimeType,
      }
    );

    await db
      .update(document)
      .set({
        processingStatus: "failed",
        processingError:
          error instanceof Error ? error.message : "Unknown error",
        processingCompletedAt: new Date(),
      })
      .where(eq(document.id, documentId));
  }
}
